{
    "collab_server" : "",
    "contents" : "# get_inv_set.R\n\n#' Wrapper where the invariant set is created\n#'\n#' \\code{get.inv.set} yields one invariant set of lethality scores per replicate, for\n#' a given isqn.object. The invariant sets are used as basis for quantile-normalizing\n#' data for independent screens and their replicates.\n\n#' @aliases getInvSet\n#' @concept invariant set normalization quantile\n#'\n#' @param data_isqn an object of class 'isqn.object', either yielded by \\code{\\link{read.screen.data}}, or\n#' by \\code{\\link{combine.screens}}. Typically the 'data_only' slot of this object\n#' contains lethality scores computed by \\code{\\link{get.leth.scores}}, which already\n#' reflect a value relative to negative and positive controls, per replicate.\n#' @param my_gamma scalar or numeric vector, with value(s) between 0 and a finite\n#' number. Its default value is \\code{NULL}. If given, it will be used to construct the\n#' invariant sets by using the relative distance between negative and positive\n#' controls' distributions. If a numeric vector is given, it must contain as many\n#' entries as columns in the data_only slot of data_isqn. A value of 1 means that\n#' the invariant set includes all lethality scores up to the ratio between the MAD\n#' of negative controls, and the sum of the MADs of negative and positive controls,\n#' assuming the robust variability measure MAD is used.\n#' @param var_type string indicating the statistic used as variability measure.\n#' Possible values are 'mad' when the median absolute deviation (MAD) is used\n#' (the default), 'IQR' when the inter-quartile range is used, and \"sd\" when the\n#' standard deviation is used.\n#' @param prop scalar between 0 and 1, corresponding to the desired proportion of\n#' lethality scores to be included in the invariant set, per replicate. The default\n#' value is 0.95. If \\code{my_gamma} is numeric, any value for this argument is ignored.\n#' @param set_shape string indicating the shape of the invariant set. It accepts\n#' \"left\" (the default), when all scores to the left of the set threshold are\n#' included, per replicate, and \"centre\", when scores included in the invariant\n#' set only exclude the largest and smallest ones, at equal frequencies.\n#' @return A logical matrix with the same dimensions as the data_only slot of data_isqn.\n#' @export\n#' @seealso \\code{\\link{get.isqnorm}} to normalize data from multiple screens using invariant\n#' sets and \\code{\\link{get.leth.scores}} to compute scores that make observations in\n#' different screens comparable.\n#'\n\nget.inv.set <- function(data_isqn, my_gamma = NULL, var_type = c(\"mad\", \"IQR\", \"sd\"),\n                        prop = 0.95, set_shape = c(\"left\",\"centre\")){\n  if (class(data_isqn) != \"isqn.object\")\n    stop(\"The input data \\\"data_isqn\\\" is not an isqn.object\")\n  if (is.null(my_gamma) & !is.numeric(prop)) stop(\"You must either define \\\"mygamma\\\" or give a numeric value to \\\"prop\\\" \")\n  var_type <- match.arg(var_type, c(\"mad\", \"IQR\", \"sd\"))\n  set_shape <- match.arg( tolower(set_shape), c(\"left\",\"centre\",\"center\"))\n  data_only <- data_isqn[[\"data_only\"]]\n  if (set_shape == \"center\") set_shape <- \"centre\"\n    if ( sum(length(prop) %in% c(1, ncol(data_only)))==0 ) stop(\"Argument \\\"prop\\\" must be a scalar or a vector with one entry per data column\")\n  if ( !is.null(my_gamma)) {\n    if ( !is.numeric(my_gamma)) stop(\"If argument \\\"my_gamma\\\" is given, it must be numeric\")\n    if ( !(length(my_gamma) %in% c(1, ncol(data_only))) ) stop(\"Argument \\\"my_gamma\\\" must be a scalar or a vector with one entry per data column\")\n  }\n  my_th <- get.th.inv.set(data_isqn = data_isqn, my_gamma = my_gamma, var_type = var_type, prop = prop, set_shape = set_shape)\n  inv_set <-  sel.scores.inv.set(data_isqn = data_isqn, th_obj = my_th)\n  inv_set\n}\n\n#' Extract well type from data_ann and format it as matrix if need be\n#'\n#' \\code{get.wtype} extracts well type info from 'data_ann' slot. This function is\n#' called by \\code{\\link{get.th.inv.set}}, \\code{\\link{sel.scores.inv.set}} and others.\n\n#' @aliases getWtype\n#' @concept invariant set normalization quantile threshold\n#'\n#' @param data_only  data matrix containing lethality scores, per replicate.\n#' @param data_ann matrix or list\n\n#' @return A list with the following elements: the first with the thresholds defining\n#' the invariant sets (one value or pair per sample, so either a vector or a matrix),\n# and the second the set_shape (a string)\n#' @export\n#' @seealso \\code{\\link{get.inv.set}} the wrapper that calls this functions and others\n#' to yield the resulting invariant sets, \\code{\\link{get.isqnorm}} to normalize data\n#' from multiple screens using invariant sets and \\code{\\link{get.leth.scores}} to compute\n#' scores that make observations in different screens comparable.\n#'\n\nget.wtype <- function(data_only, data_ann)\n{\n  # Same annotation, as matrix, for all data\n  if ( !is.null(dim(data_ann)) ){\n    wtype_mat <- matrix(rep(as.character(data_ann$wtype), ncol(data_only)),\n                        nrow=nrow(data_only), ncol=ncol(data_only))\n    # Different annotation per replicate, in matrix that is part of data_ann, a list\n  } else if (class(data_ann) == \"list\") {\n    wtype_mat <- data_ann[[\"wtype_ann\"]]\n  }\n}\n\n#' Compute thresholds that define invariant sets per replicate\n#'\n#' \\code{get.th.inv.set} Compute thresholds to be used later on for constructing\n#' invariant sets. Two methods are available: using the distance between negative\n#' and positive controls to determine the invariant set, and including in the set\n#' a proportion of the lethality scores. To be used internally, it is called by\n#' get.inv.set.\n\n#' @aliases getThInvSet\n#' @concept invariant set normalization quantile threshold\n#'\n#' @inheritParams get.inv.set\n\n#' @return A list with the following elements: the first with the thresholds defining\n#' the invariant sets (one value or pair per sample, so either a vector or a matrix),\n# and the second the set_shape (a string)\n#' @export\n#' @seealso \\code{\\link{get.inv.set}} the wrapper that calls this functions and others\n#' to yield the resulting invariant sets, \\code{\\link{get.isqnorm}} to normalize data\n#' from multiple screens using invariant sets and \\code{\\link{get.leth.scores}} to compute\n#' scores that make observations in different screens comparable.\n#'\n\nget.th.inv.set <- function(data_isqn, my_gamma = NULL, var_type = c(\"mad\", \"IQR\", \"sd\"),\n                        prop = 0.95, set_shape = c(\"left\",\"centre\")){\n  data_only <- data_isqn[[\"data_only\"]]\n  set_shape <- match.arg(tolower(set_shape), c(\"left\",\"centre\"))\n  if ( !is.null(my_gamma)) {\n    if ( !is.numeric(my_gamma)) stop(\"If argument \\\"my_gamma\\\" is given, it must be numeric\")\n    if ( !(length(my_gamma) %in% c(1, ncol(data_only))) ) stop(\"Argument \\\"my_gamma\\\" must be a scalar or a vector with one entry per data column\")\n  }\n  # Extract wtype_ann: either a matrix or single colum - if the latter, expanded to be a matrix\n  # Result: wtype_ann has the same dimensions as data_only\n  data_ann  <- data_isqn[[\"data_ann\"]]\n  wtype_mat <- get.wtype(data_only, data_ann)\n  var_type <- match.arg(var_type, c(\"mad\", \"IQR\", \"sd\"))\n  let_res <- get.list.res(data_only = data_isqn[[\"data_only\"]], wtype_mat = wtype_mat)\n  # Compute threshold using gamma, defined as a relation between variability between negative and positive controls\n  if ( !is.null(my_gamma) ){\n    if (var_type == \"mad\"){\n      mad_neg <- unlist( lapply( let_res[[\"let_neg\"]], mad, na.rm = T ) )\n      mad_pos <- unlist( lapply( let_res[[\"let_pos\"]], mad, na.rm = T ) )\n    } else if (var_type == \"IQR\"){\n      mad_neg <- unlist( lapply( let_res[[\"let_neg\"]], IQR, na.rm = T ) )\n      mad_pos <- unlist( lapply( let_res[[\"let_pos\"]], IQR, na.rm = T ) )\n    } else if (var_type == \"sd\"){\n      mad_neg <- unlist( lapply( let_res[[\"let_neg\"]], sd, na.rm = T ) )\n      mad_pos <- unlist( lapply( let_res[[\"let_pos\"]], sd, na.rm = T ) )\n    }\n    # Now to compute the threshold, per screen\n      my_th <- mad_neg/( mad_neg + ( mad_pos/my_gamma ) )\n  } else if ( set_shape == \"left\" ){\n    # Compute threshold to include proportion 'prop' of lethality scores in invariant set\n    if (length(prop) == 1)  { my_th <- apply(let_res[[\"mat_let\"]], 2, quantile, probs = prop, na.rm = T) }\n    if (length(prop) == ncol(data_only)) {\n      my_th <- NULL\n      for(xj in 1:ncol(data_only)) my_th <- c( my_th, quantile(let_res[[\"mat_let\"]][, xj], probs = prop[xj], na.rm = T) )\n    }\n  }\n    else if ( set_shape == \"centre\" ) {\n      if (length(prop) == 1)  {\n        my_th1 <- apply(let_res[[\"mat_let\"]], 2, quantile, probs = (1-prop)/2, na.rm = T)\n        my_th2 <- apply(let_res[[\"mat_let\"]], 2, quantile, probs = prop+(1-prop)/2, na.rm = T)\n        my_th <- cbind(my_th1, my_th2)\n        }\n      if (length(prop) == ncol(data_only)) {\n        my_th <- NULL\n        for(xj in 1:ncol(data_only)) { ####\n          my_th1 <- quantile(let_res[[\"mat_let\"]][, xj], probs = (1-prop[xj])/2, na.rm = T)\n          my_th2 <- quantile(let_res[[\"mat_let\"]][, xj], probs = prop[xj]+(1-prop[xj])/2, na.rm = T)\n          my_th <- cbind(my_th1, my_th2)\n          }\n        }\n    }\n  # Threshold and set_shape in list as result\n  res <- list( threshold = my_th, set_shape = set_shape )\n  res\n}\n\n\nget.th.inv.set.old <- function(data_isqn, my_gamma = NULL, var_type = c(\"mad\", \"IQR\", \"sd\"),\n                           prop = 0.95, set_shape = c(\"left\",\"centre\")){\n  data_only <- data_isqn[[\"data_only\"]]\n  if (length(set_shape)>1) set_shape <- \"left\"\n  if ( !is.null(my_gamma)) {\n    if ( !is.numeric(my_gamma)) stop(\"If argument \\\"my_gamma\\\" is given, it must be numeric\")\n    if ( !(length(my_gamma) %in% c(1, ncol(data_only))) ) stop(\"Argument \\\"my_gamma\\\" must be a scalar or a vector with one entry per data column\")\n  }\n  # Extract wtype_ann: either a matrix or single colum - if the latter, expanded to be a matrix\n  # Result: wtype_ann has the same dimensions as data_only\n  data_ann  <- data_isqn[[\"data_ann\"]]\n  wtype_mat <- get.wtype(data_only, data_ann)\n  var_type <- match.arg(var_type, c(\"mad\", \"IQR\", \"sd\"))\n  let_res <- get.list.res(data_only = data_isqn[[\"data_only\"]], wtype_mat = wtype_mat)\n  # Compute threshold using gamma, defined as a relation between variability between negative and positive controls\n  if ( !is.null(my_gamma) ){\n    if (var_type == \"mad\"){\n      mad_neg <- unlist( lapply( let_res[[\"let_neg\"]], mad, na.rm = T ) )\n      mad_pos <- unlist( lapply( let_res[[\"let_pos\"]], mad, na.rm = T ) )\n    } else if (var_type == \"IQR\"){\n      mad_neg <- unlist( lapply( let_res[[\"let_neg\"]], IQR, na.rm = T ) )\n      mad_pos <- unlist( lapply( let_res[[\"let_pos\"]], IQR, na.rm = T ) )\n    } else if (var_type == \"sd\"){\n      mad_neg <- unlist( lapply( let_res[[\"let_neg\"]], sd, na.rm = T ) )\n      mad_pos <- unlist( lapply( let_res[[\"let_pos\"]], sd, na.rm = T ) )\n    }\n    my_th <- mad_neg/( mad_neg + ( mad_pos/my_gamma ) )\n  }\n} else if ( set_shape == \"left\" ){\n    # Compute threshold to include proportion 'prop' of lethality scores in invariant set\n    if (length(prop) == 1)  { my_th <- apply(let_res[[\"mat_let\"]], 2, quantile, probs = prop, na.rm = T) }\n    if (length(prop) == ncol(data_only)) {\n      my_th <- NULL\n      for(xj in 1:ncol(data_only)) my_th <- c( my_th, quantile(let_res[[\"mat_let\"]][, xj], probs = prop[xj], na.rm = T) )\n    }\n  }\n  else if ( set_shape == \"centre\" ) {\n    if (length(prop) == 1)  {\n      my_th1 <- apply(let_res[[\"mat_let\"]], 2, quantile, probs = (1-prop)/2, na.rm = T)\n      my_th2 <- apply(let_res[[\"mat_let\"]], 2, quantile, probs = prop+(1-prop)/2, na.rm = T)\n      my_th <- cbind(my_th1, my_th2)\n    }\n    if (length(prop) == ncol(data_only)) {\n      my_th <- NULL\n      for(xj in 1:ncol(data_only)) { ####\n        my_th1 <- quantile(let_res[[\"mat_let\"]][, xj], probs = (1-prop[xj])/2, na.rm = T)\n        my_th2 <- quantile(let_res[[\"mat_let\"]][, xj], probs = prop[xj]+(1-prop[xj])/2, na.rm = T)\n        my_th <- cbind(my_th1, my_th2)\n      }\n    }\n  }\n  # Threshold and set_shape in list as result\n  res <- list( threshold = my_th, set_shape = set_shape )\n  res\n}\n\n\n#' Creates an object indicating observations in invariant set\n#'\n#' \\code{sel.scores.inv.set} uses data_isqn and a threshold object and returns a\n#' logical matrix, with the same dimensions as data_only, with \\code{TRUE} for every\n#' lethality score in the invariant set, and \\code{FALSE} for all others. To be used\n#' internally, it is called by get.inv.set.\n\n#' @aliases selScoresInvSet\n#' @concept invariant set normalization quantile threshold\n#'\n#' @param th_obj object containing thresholds per replicate, as returned by\n#' get.th.inv.set\n#' @inheritParams get.inv.set\n#'\n#' @return A logical matrix with the same number of columns as the data_only slot of data_isqn,\n#' and as many rows as annotated with \"sample\" in the data_only slot\n#' @export\n#' @seealso \\code{\\link{get.inv.set}} the wrapper that calls this functions and others\n#' to yield the resulting invariant sets, \\code{\\link{get.th.inv.set}} that produces the\n#' thresholds per replicate, \\code{\\link{get.isqnorm}} to normalize data from multiple\n#' screens using invariant sets and \\code{\\link{get.leth.scores}} to compute scores that\n#' make observations in different screens comparable.\n\nsel.scores.inv.set <- function(data_isqn, th_obj){\n  if ( (!is.list(th_obj)) | (length(th_obj) != 2) ) stop(\"Argument \\\"th_obj\\\" should be a list with two elements\")\n  if ( class(data_isqn) != \"isqn.object\" ) stop(\"The input data \\\"data_isqn\\\" is not an isqn.object\")\n  my_th <- th_obj[[\"threshold\"]]\n  set_shape <- th_obj[[\"set_shape\"]]\n  data_only <- data_isqn[[\"data_only\"]]\n  # Extract wtype_ann: either a matrix or single colum - if the latter, expanded to be a matrix\n  # Result: wtype_ann has the same dimensions as data_only\n  data_ann  <- data_isqn[[\"data_ann\"]]\n  wtype_mat <- get.wtype(data_only, data_ann)\n  let_res <- get.list.res(data_only, wtype_mat)\n  inv_set <- matrix(FALSE, nrow = nrow(let_res[[\"mat_let\"]]), ncol = ncol(data_only))\n  colnames(inv_set) <- colnames(data_only)\n  if (set_shape == \"left\") {\n    for(xj in 1:ncol(data_only)) inv_set[, xj] <- let_res[[\"mat_let\"]][, xj] <= my_th[xj]\n  } else if (set_shape == \"centre\"){\n    for(xj in 1:ncol(data_only)) inv_set[, xj] <- (let_res[[\"mat_let\"]][, xj] >= my_th[xj,1]) & (let_res[[\"mat_let\"]][, xj] <= my_th[xj,2])\n    }\n inv_set\n}\n\n\n#' Computes proportion of scores included in invariant sets\n#'\n#' \\code{get.inv.set.prop} uses data_isqn and a threshold object and returns a\n#' vector of proportions of scores included in invariant sets, per replicate.\n#' It is typically used when a \\code{my_gamma} is chosen to select invariant sets,\n#' yielding a check on the built sets.\n\n#' @aliases getInvSetProp\n#' @concept invariant set normalization quantile threshold\n#'\n#' @param th_obj object containing thresholds per replicate, as returned by\n#' \\code{\\link{get.th.inv.set}}.\n#' @param plot logical, indicating if a barplot is to be made of the result. Defaults\n#' to \\code{FALSE}, when no plot is produced.\n#' @param cols_list vector of colours to be used for the barplot, so if given it must\n#' be as long as the number of columns in data_only slot of data_isqn. If \\code{\\link{get.pdata}}\n#' was used to read the phenotypic data table, its slot cols_list can be used as input\n#' for this argument. By default, a vector of colours created by \\code{\\link{rainbow}} will\n#' be used, a different one for each column in data_only.\n#' @inheritParams get.inv.set\n#'\n#' @return A vector as long as the number of columns in the data_only slot of data_isqn,\n#' with each entry corresponding to the proportion of scores included in an invariant set.\n#' If plot = TRUE, makes also a barplot of the computed proportions.\n#' @export\n#' @seealso \\code{\\link{get.inv.set}} the wrapper function that yields invariant sets,\n#' \\code{\\link{get.th.inv.set}} that produces the thresholds per replicate, \\code{\\link{get.isqnorm}}\n#' to normalize data from multiple screens using invariant sets and \\code{\\link{get.leth.scores}}\n#' to compute scores that make observations in different screens comparable.\n\n\nget.inv.set.prop <- function(data_isqn, th_obj, plot = FALSE, cols_list = NULL){\n  if ( (!is.list(th_obj)) | (length(th_obj) != 2) ) stop(\"Argument \\\"th_obj\\\" should be a list with two elements\")\n  if ( class(data_isqn) != \"isqn.object\" ) stop(\"The input data \\\"data_isqn\\\" is not an isqn.object\")\n\n  inv_set <- sel.scores.inv.set(data_isqn, th_obj)\n  prop_inc <- apply(inv_set, 2, mean, na.rm = T)\n  if (plot) {\n    if (is.null(cols_list))    {\n      cols_list <- rainbow( ncol(data_isqn[[\"data_only\"]]) ) } else {\n        if ( length(cols_list) < ncol(data_isqn[[\"data_only\"]]) ) {\n          cols_list <- rainbow( ncol(data_isqn[[\"data_only\"]]) ) }\n      }\n    barplot(prop_inc, col = cols_list)\n    if( length(cols_list) < ncol(data_isqn[[\"data_only\"]])) warning(\"The length of argument \\\"cols_list\\\" is not equal\n                                                                    to the total number of replicates, so default colours were used for the plot.\")\n  }\n  prop_inc\n}\n\n\n\n",
    "created" : 1510655032447.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3120196149",
    "id" : "AC85565",
    "lastKnownWriteTime" : 1510657260,
    "last_content_update" : 1510657260222,
    "path" : "/media/renee/Seagate Expansion Drive/Projects/bachas costa/rscreenorm/R/get_inv_set.R",
    "project_path" : "R/get_inv_set.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}