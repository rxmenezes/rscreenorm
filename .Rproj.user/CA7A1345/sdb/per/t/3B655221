{
    "collab_server" : "",
    "contents" : "# read_screen_data.R\n#\n#' Reads screen data from a tab-delimited file\n#'\n#' \\code{read.screen.data} reads in a tab-delimited file containing annotation\n#' in the first k columns and screen data per replicate in the remaining columns.\n#' Annotation columns include gene (target) id as well as feature/well type, where library\n#' features, positive and negative controls are identified. Arrayed screens\n#' typically also include a plate identifier. All data columns are assumed to have\n#' the same annotation. If that is not the case, the data is assumed to correspond to\n#' different screens, and it must be loaded for each separate screen first before combining\n#' it into a single object using \\code{\\link{combine.screens}}.\n\n#' @aliases readScreenData\n#' @concept input screen siRNA CRISPR CRISPR-Cas9 crispr-cas9 CRISPR/Cas9 crispr/cas9\n#'\n#' @param mydir string, indicating the complete folder path where the data file\n#' is to be found. It is assumed it ends without any (forward or backward) slashes, for example\n#' '/home/projects' instead of '/home/projects/'.\n#' @param filename string, the name of the tab-delimited file containing the data\n#' to be read, including the file extension.\n#' @param sep the separator to be used while reading in the data file,\n#'        containing a value accepted by read.delim.\n#' @param check_names logical, indicating whether or not the column names in the data\n#'        file need to be checked for consistency or not. To be used while reading\n#'        in the data file. Defaults to \\code{FALSE}, when comparability between\n#'       column names in the data and in the phenotypic data table is guaranteed.\n#' @param ann_cols_names vector of strings containing the names of the annotation\n#' columns. It is assumed that these columns are the first few ones in the data file.\n#' @param n_ann_cols an integer giving the number of annotation columns (from the\n#' first one) in the data read. Any value given is only used if ann_cols_names is\n#' \\code{NULL}, otherwise it is ignored. If ann_cols_names is given and n_ann_cols\n#' is left empty, n_ann_cols is by default the length of ann_cols_names.\n#' @param wtype_col string with the name of the annnotation column corresponding\n#' to the well annotation column.\n#' @param wtype_lab labels in wtype_col variable corresponding to library/sample\n#' features, positive and negative controls,\n#' respectively. Defaults to 'c(\"sample\",\"pos\", \"neg\")'.\n#' @param use_plate logical indicating whether or not the data contains a plate variable.\n#' Defaults to \\code{FALSE}. If \\code{TRUE}, the plate will be used when computing the lethality scores\n#' later on with \\code{\\link{get.leth.scores}}.\n#' @param plate_var string with the name of the plate variable.\n#'   Only needed if use_plate is \\code{TRUE}. Defaults to \"plate\".\n#' @return An object of class isqn.object.\n#' @export\n#' @seealso \\code{\\link{combine.screens}} to combine data from multiple screens,\n#' \\code{\\link{combine.pdata}} to combine pdata from multiple screens into a single object,\n#' and \\code{\\link{get.leth.scores}} to compute scores that make observations in\n#' different replicates and screens comparable.\n#'\n\nread.screen.data <- function(mydir, filename, sep = \"\\t\", check_names = FALSE, ann_cols_names = NULL,\n                             n_ann_cols = length(ann_cols_names),\n                             wtype_col = \"wtype\", wtype_lab = c(\"sample\", \"pos\", \"neg\"),\n                             use_plate = FALSE, plate_var = \"plate\") {\n    if ((is.null(ann_cols_names)) & (n_ann_cols < 1))\n        stop(\"Please provide either column names for annotation or a non-zero integer corresponding to the number of columns to be used\")\n    if (!is.logical(check_names)) stop(\"Argument \\\"check_names\\\" must be either TRUE or FALSE\")\n    data_read <- read.delim(paste(mydir, filename, sep = \"/\"), sep = sep, check.names = check_names)\n    if (length(ann_cols_names) != sum(colnames(data_read) %in% ann_cols_names))\n        stop(\"Column names given in ann_cols_names do not match those in the data file read\")\n    if ((sum(colnames(data_read) %in% wtype_col)) == 0)\n        stop(\"Column name given by wtype_col does not match any column name in the data file read\")\n    if (length(wtype_lab) != 3)\n        stop(\"wtype_lab must contain exactly three feature labels\")\n    if (!is.logical(use_plate)) stop(\"Argument \\\"use_plate\\\" must be either TRUE or FALSE\")\n    if (!is.null(ann_cols_names)) {\n        data_ann <- data_read[, ann_cols_names]\n        n_ann_cols <- length(ann_cols_names)\n    } else {\n        data_ann <- data_read[, 1:n_ann_cols]\n    }\n    wtype <- as.character(data_ann[, wtype_col])\n    wtype[wtype == wtype_lab[1]] <- \"sample\"\n    wtype[wtype == wtype_lab[2]] <- \"pos\"\n    wtype[wtype == wtype_lab[3]] <- \"neg\"\n    data_ann[, wtype_col] <- NULL\n    data_ann$wtype <- wtype\n    if (use_plate){\n      if (!is.character(plate_var)) stop(\"Argument \\\"plate_var\\\" must be character\")\n      if ( sum(colnames(data_ann) %in% plate_var ) == 0 ) stop(\"Error: \\\"use_plate\\\" is TRUE but there is no column called \\\"use_plate\\\" amongst the annotation columns\")\n      data_ann$plate <- data_ann[, plate_var]\n      data_ann[, plate_var] <- NULL\n    }\n    data_only <- as.matrix(data_read[, (n_ann_cols + 1):ncol(data_read)])\n    if (!is.numeric(data_only))\n        stop(\"All non-annotation columns in the data read must be numeric\")\n    data_isqn <- list(data_ann = data_ann, data_only = data_only, use_plate = use_plate)\n    class(data_isqn) <- \"isqn.object\"\n    data_isqn\n}\n\n#' Combines different screen data objects into a single one.\n#'\n#' \\code{combine.screens} combines data from multiple screens, already read in\n#' using read.screen.data into a single isqn.object. The different screens\n#' involve the same set of library features, but may use different plate sets and/or\n#' different (numbers of) controls. As such, different screens share annotation\n#' relating to the library features, such as (target) gene id, but are likely to\n#' have different plate and/or well annotation. The total number of features\n#' measured per screen must be the same for all experiments.\n#'\n#' @param list_isqn a list of isqn objects, such as the ones produced by reading\n#' data with read.screen.data.\n#' @return An object of class isqn.object.\n#' @export\n#' @seealso \\code{\\link{read.screen.data}} to read data for individual screens,\n#' \\code{\\link{combine.pdata}} for combining phenotypic data tables corresponding\n#' to different screens that are to be normalized together, and\n#' \\code{\\link{get.leth.scores}} to compute lethality scores for data corresponding\n#' to multiple screens\n#'\n##\n# combine.screens\n# The output includes a data_ann slot with the common annotation, obtained from the first screen, as well as separate wtype_ann and\n# plate_ann matrices with replicate_specific feature annotation\n# Note: the function does not check if all annotation columns (except for plate, well)\n# are indeed the same across experiments\n\ncombine.screens <- function(list_isqn){\n  if (!is.list(list_isqn)) stop(\"The argument \\\"list_isqn\\\" must be a list.\")\n  class_objs <- unlist( lapply(list_isqn, class) )\n  if (any( class_objs != \"isqn.object\")) stop(\"All elements of list_isqn must be of class isqn.object\")\n  n_screens <- length(list_isqn)\n  my_use_plate <- NULL\n  for(xi in 1:n_screens) my_use_plate <- c(my_use_plate, list_isqn[[xi]][[\"use_plate\"]])\n  if (length(my_use_plate) < n_screens) stop(\"Not all screens have valid \\\"use_plate\\\" argument\")\n  if ( (sum(my_use_plate) < n_screens) & (sum(my_use_plate)>0) ) stop(\"Argument \\\"use_plate\\\"must have\n                                                                  the same value for all screens\")\n  xi <- 1\n  data_only <- list_isqn[[ xi ]][[\"data_only\"]]\n  nreps <- ncol(data_only)\n  screen <- rep(1, nreps)\n  data_ann  <- list_isqn[[ xi ]][[\"data_ann\"]]\n  wtype_ann <- matrix(rep(as.character(data_ann[,\"wtype\"]), ncol(data_only)),\n                      nrow=nrow(data_only), ncol=ncol(data_only))\n  colnames(wtype_ann) <- colnames(data_only)\n  if ( my_use_plate[xi] ){\n    plate_ann <- matrix(rep(as.character(data_ann[,\"plate\"]), ncol(data_only)),\n                        nrow=nrow(data_only), ncol=ncol(data_only))\n    colnames(plate_ann) <- colnames(data_only)\n  }\n  data_ann[,\"wtype\"] <- data_ann[,\"plate\"] <- NULL\n  data_ann_common <- data_ann\n  for(xi in 2:n_screens)\n  {\n    if (nrow(data_only) != nrow(list_isqn[[xi]][[\"data_only\"]]))\n         stop(paste(\"Screen\",xi,\" has different total number of features\") )\n    data_only2 <- list_isqn[[xi]][[\"data_only\"]]\n    nreps2 <- ncol(data_only2)\n    screen <- c( screen, rep(xi, nreps2) )\n    data_only <- cbind(data_only, data_only2)\n    data_ann <- list_isqn[[xi]][[\"data_ann\"]]\n    wtype_ann1 <- matrix(rep(as.character(data_ann[,\"wtype\"]), ncol(data_only2)),\n                        nrow=nrow(data_only2), ncol=ncol(data_only2))\n    colnames(wtype_ann1) <- colnames(data_only2)\n    wtype_ann <- cbind(wtype_ann, wtype_ann1)\n    if ( my_use_plate[xi] ){\n      plate_ann1 <- matrix(rep(as.character(data_ann[,\"plate\"]), ncol(data_only2)),\n                          nrow=nrow(data_only2), ncol=ncol(data_only2))\n      colnames(plate_ann1) <- colnames(data_only2)\n      plate_ann <- cbind(plate_ann, plate_ann1)\n    }\n    nreps <- nreps+nreps2\n  }\n  # The following statement makes sure plate_ann always exists,\n  # even when use_plate==FALSE for all screens used\n  if(sum(my_use_plate) == 0) plate_ann <- NULL\n  mydata_ann <- list(data_ann = data_ann_common, wtype_ann = wtype_ann, plate_ann = plate_ann, screen = screen)\n res <- list(data_ann = mydata_ann, data_only = data_only, use_plate = my_use_plate)\n class(res) <- \"isqn.object\"\n res\n}\n",
    "created" : 1509541253871.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "803310425",
    "id" : "3B655221",
    "lastKnownWriteTime" : 1509543066,
    "last_content_update" : 1509543066286,
    "path" : "/media/renee/Seagate Expansion Drive1/Projects/bachas costa/rscreenorm/R/read_screen_data.R",
    "project_path" : "R/read_screen_data.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}