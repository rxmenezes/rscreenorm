{
    "collab_server" : "",
    "contents" : "# get_pdata.R\n\n#' Reads phenotypic data from a tab-delimited file\n#'\n#' \\code{get.pdata} reads in a tab-delimited file containing sample annotation, such as\n#' a phenotypic data table, and creates variables useful for making graphs later on.\n#' The input file must have as many rows as replicates included in the study, and as many\n#' columns as phenotype variables, which must include at least a variable containing replicate\n#' names (the same as given in the data file), one including cell line ids and one including\n#' a condition or treatment.\n\n#' @aliases getPdata\n\n#' @param mydir string; the complete folder path where the data file\n#' is to be found. It is assumed it ends without any (forward or backward) slashes, for example\n#' '/home/projects' instead of '/home/projects/'.\n#' @param filename string; the name of the tab-delimited file containing the data\n#' to be read, including the file extension.\n#' @param sep the separator to be used while reading in the data file,\n#'        containing a value accepted by read.delim.\n#' @param check_names logical, indicating whether or not the column names in the data\n#'        file need to be checked for consistency or not. To be used while reading\n#'        in the data file. Defaults to FALSE, when\n#'        column names are left unaltered by R.\n#' @param names_var string; name of the variable containing the replicate names,\n#' corresponding to the same names given in the data file.\n#' @param clines_var string; name of the variable containing the cell line names. This may be\n#' used later on for graph annotation. This argument is expected to be declared. Of course, the\n#' user can instead declare here any variable considered interesting to distinguish sets of\n#' replicates, such as the replicate number.\n#' @param treat_var string; name of the variable containing the treatment or condition\n#' to the well annotation column. Optional.\n#' @param sample_ids a character vector containing sample ids yielded by the data file. This\n#' is typically the result of colnames of data_only, a slot of the result of read.screen.data. The function\n#' checks if the ids given in sample_ids are the same, and are in the same order, as those in names_var.\n#' If they are the same but not in the same order, the pdata table has rows re-ordered so that they match\n#' the order in sample_ids.  If values in sample_ids are not a permutation of those in names_bar,\n#' the function yields an error. We strongly suggest users make use of this variable, but they may ignore\n#' it and no check is made.\n#' @return A list containing the pdata read with all variables, a colour variable coding for the cell line variable,\n#' as well as a vector of the variable names\n#' @export\n#' @seealso \\code{\\link{read.screen.data}} to read in screen data, \\code{\\link{combine.pdata}}\n#' to combine pdata from multiple screens into a single object, and \\code{\\link{get.leth.scores}}\n#' to compute scores that make observations in different screens comparable.\n#'\n\nget.pdata <- function(mydir, filename, sep = \"\\t\", check_names = FALSE, names_var = \"names\",\n                      clines_var = \"clines\", treat_var = \"treat\", sample_ids = NULL) {\n    data_read <- read.delim(paste(mydir, filename, sep = \"/\"), sep = sep, check.names = check_names)\n    if (sum(colnames(data_read) %in% clines_var) == 0)\n        stop(\"The variable name clines_var does not exist in the file read\")\n    if (sum(colnames(data_read) %in% treat_var) == 0) {\n        warning(\"The variable name treat_var does not exist in the file read\")\n        treat_var <- NULL\n    }\n    if (sum(colnames(data_read) %in% names_var) == 0)\n        stop(\"The variable name names_var does not exist in the file read\")\n    if (!is.null(sample_ids)) {\n        if (sum(as.character(data_read[, names_var]) %in% sample_ids) != length(sample_ids))\n            stop(\"The sample_ids given do not all match/are matched by the ids in the names_var variable\")\n        ids_mat <- data.frame(sample_ids = as.character(sample_ids), orig_order = 1:length(sample_ids), stringsAsFactors = F)\n        if (!all(ids_mat$sample_ids == data_read[, names_var])) {\n            ids_mat <- ids_mat[order(ids_mat$sample_ids), ]\n            data_read <- data_read[order(as.character(data_read[, names_var])), ]\n            if (!all(ids_mat$sample_ids == as.character(data_read[, names_var])))\n                warning(\"It was not possible to get sample_ids and names_var in the pheno data in the same order - please check\")\n            pdata <- data_read[order(ids_mat$orig_order), ]  # Note: pdata is only re-ordered if sample_ids is NULL\n        } else {\n            pdata <- data_read\n        }\n    }\n    # Make colour vector, with one colour per cell line\n    cols_list <- var.in.colour(data_read[, clines_var])\n    pdata$cols_vec <- cols_list[[1]]\n    list_vars <- c(names_var, clines_var, treat_var)\n    # Output object: a list including the pdata, the cols_list list (for legends) and the list of variable names (names/ids, clines, treat_var)\n    list(pdata = pdata, cols_list = cols_list, list_vars = list_vars)\n}\n\n#' Combines pdata objects corresponding to multiple screens\n#'\n#' \\code{combine.pdata} combines pdata from multiple screens, already read in\n#' using get.pdata into a single pdata object. Variables are combined to allow for\n#' using them for plots later on. Variable names are standardized to allow for\n#' combining all observations smoothly. Other variables that exist in one pdata and not in\n#' the other, receive NA for the extra observations.\n#'\n#' @param list_pdata a list of pdata objects, read in using get.pdata\n#' @aliases combinePdata\n#' @return A list containing the stacked pdata objects, a single colour variable coding for the cell line variable, as well as\n#' a character vector with the variable names containing replicate names, cell line ids and treatment/condition.\n#' @export\n#' @seealso \\code{\\link{read.screen.data}} to read in screen data, \\code{\\link{combine.screens}}\n#' to combine data from multiple screens,  and \\code{\\link{get.leth.scores}} to compute scores\n#' that make observations in different screens comparable.\n#'\n\n\ncombine.pdata <- function(list_pdata){\n  n_screens <- length(list_pdata)\n  list_vars <- c(\"names\", \"clines\", \"treat\")\n  xi <- 1\n  my_entry <- list_pdata[[xi]]\n  my_pdata <- my_entry[[\"pdata\"]]\n  vars_list <- my_entry[[\"list_vars\"]]\n  pdata1 <- my_pdata[, vars_list]\n  if ( length(vars_list) < 3)  {\n    pdata1$treat <- rep(NA, nrow(pdata1))\n  }\n  names(pdata1) <- list_vars\n  pdata_all <- apply(pdata1, 2, as.character)\nif(n_screens >= 2) {\n  for(xi in 2:n_screens)\n  {\n    my_entry <- list_pdata[[xi]]\n    my_pdata <- my_entry[[\"pdata\"]]\n    vars_list <- my_entry[[\"list_vars\"]]\n    pdata1 <- my_pdata[, vars_list]\n    if ( length(vars_list) < 3)  {\n      pdata1$treat <- rep(NA, nrow(pdata1))\n    }\n    names(pdata1) <- list_vars\n    pdata1 <- apply(pdata1, 2, as.character)\n    if (ncol(pdata1) < ncol(pdata_all)) stop(paste(\"pdata\",xi,\"does not contain all required variables\"))\n    pdata_all <- rbind(pdata_all, pdata1)\n  }\n}\n  cols_list <- var.in.colour(pdata_all[, list_vars[2] ])\n  pdata_all <- data.frame(pdata_all, check.names=FALSE)\n  pdata_all$cols_vec <- cols_list[[1]]\n  # Output object: a list including the pdata, the cols_list list (for legends) and the list of variable names (names/ids, clines, treat_var)\n  list(pdata = pdata_all, cols_list = cols_list, list_vars = list_vars)\n}\n\n# @param keep_only variable indicating if only a subset of the variables in each pdata\n# is to be kept when merging them all. By default this is TRUE, when only variables corresponding\n# to names_var, clines_var and treat_var (if it exists) are kept. Alternatively, a string of\n# variable names which will be preserved when found in separate pdata. Any other value will be\n# handled as the default.\n\ncombine.pdata.old <- function(list_pdata, keep_only = TRUE){\n  n_screens <- length(list_pdata)\n  list_vars <- c(\"names\", \"clines\", \"treat\")\n  if (is.logical(keep_only)) {\n    keep_only_log <- keep_only\n    keep_vars <- NULL\n  }\n  if (is.character(keep_only)) {\n    keep_vars <- keep_only\n    keep_only_log <- FALSE\n  }\n  if ( (!is.character(keep_only)) & (!is.logical(keep_only)) )\n    warning(\"Argument \\\"keep_only\\\" invalid - default value used\")\n  xi <- 1\n  my_entry <- list_pdata[[xi]]\n  my_pdata <- my_entry[[\"pdata\"]]\n  vars_list <- my_entry[[\"list_vars\"]]\n  if (!is.null(keep_vars)) {\n    vars_list <- keep_vars\n  }\n  pdata1 <- my_pdata[, vars_list]\n  if (keep_only_log & (length(vars_list) < 3) ) {\n    pdata1$treat <- rep(NA, nrow(pdata1))\n  }\n  names(pdata1) <- list_vars\n  pdata_all <- apply(pdata1, 2, as.character)\n  if(n_screens >= 2) {\n    for(xi in 2:n_screens)\n    {\n      my_entry <- list_pdata[[xi]]\n      my_pdata <- my_entry[[\"pdata\"]]\n      vars_list <- my_entry[[\"list_vars\"]]\n      if (!is.null(keep_vars)) {\n        vars_list <- keep_vars\n      }\n      pdata1 <- my_pdata[, vars_list]\n      if (keep_only_log & (length(vars_list) < 3) ) {\n        pdata1$treat <- rep(NA, nrow(pdata1))\n      }\n      names(pdata1) <- list_vars\n      pdata1 <- apply(pdata1, 2, as.character)\n      if (ncol(pdata1) < ncol(pdata_all)) stop(paste(\"pdata\",xi,\"does not contain all required variables\"))\n      pdata_all <- rbind(pdata_all, pdata1)\n    }\n  }\n  cols_list <- var.in.colour(pdata_all[, list_vars[2] ])\n  pdata_all$cols_vec <- cols_list[[1]]\n\n  # Output object: a list including the pdata, the cols_list list (for legends) and the list of variable names (names/ids, clines, treat_var)\n  list(pdata = pdata_all, cols_list = cols_list, list_vars = list_vars)\n}\n\n",
    "created" : 1509542927918.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2239327377",
    "id" : "CF872CCF",
    "lastKnownWriteTime" : 1490348456,
    "last_content_update" : 1490348456,
    "path" : "/media/renee/Seagate Expansion Drive1/Projects/bachas costa/rscreenorm/R/get_pdata.R",
    "project_path" : "R/get_pdata.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}